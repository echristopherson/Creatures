MAKeyedArchiver is a (mostly) drop-in replacement for NSKeyedArchiver and NSKeyedUnarchiver. It is free, as in speech and beer, for all uses. If you redistribute the source code, please retain this README file along with attributions. Otherwise, you are free to redistribute as you wish.

MAKeyedArchiver and MAKeyedUnarchiver are meant to function as replacements for their NS equivalents in situations where the NS classes are too slow. When encoding large object graphs, NSKeyedArchiver is often unacceptably slow. MAKeyedArchiver sees an improvement of roughly 15x in this area, and produces files roughly 7x smaller, for the object graphs that I have tested. The file format is *not* the same, but the APIs are. You can't read files with one archiver that were written with the other, but your -initWithCoder: and encodeWithCoder: methods should be able to work unchanged.

MAKeyedArchiver does not do everything that NSKeyedArchiver does. Most notably, there is no type checking. NSKeyedArchiver will flag an error if you encode a float as a key, then try to decode it as an int. MAKeyedArchiver will silently feed you junk. If your code works correctly with NSKeyedArchiver, it should work correctly with MAKeyedArchiver, unless you're relying on exceptions being thrown in the error cases.

On Jaguar, NSKeyedArchiver implements some special, undocumented methods that certain Foundation classes, like NSString or NSArray use to encode themselves. In order to make MAKeyedArchiver work on Jaguar and Panther, some ugly things are done to keep everything compatible. The _encodeArrayOfObjectsForKey: and _decodeArrayOfObjectsForKey: methods are implemented to work as they appear to work in Jaguar, which allows NSArrays to be encoded and decoded on Jaguar. NSString and NSData are manually encoded by the archiver; their encodeWithCoder: and initWithCoder: methods are never called. If all you need is Panther compatibility, all of these hacks can be taken out. None of the Cocoa classes that I am encoding use any private methods in the coder on Jaguar. On the other hand, it is possible that other classes, particularly plist classes, other than the ones I've actually tried archiving will require special handling.

The function MyErrorLog() is used in the code to signal errors. This comes from the project that this archiver is used in, so you'll need a replacement for it. In the project, MyErrorLog() throws up a dialog with details about the error, giving the user an option to save or quit, etc. To replace it, the simplest way would be to make it call NSLog() and then abort() or throw an exception. I think this is the only extra code you will have to supply.

The archiver format is actually quite inefficient, space-wise. It achieves small files by gzipping the output. If you need more speed and don't care about space consumption, you may want to remove the gzipping, which will result in files that are about twice as large as NSKeyedArchiver's files, but the archiving process will be about 50% faster.

Data integrity is ensured with an MD5 sum. If you really, really need extra speed, you could remove this check as well, but I wouldn't recommend it.

Gzip and MD5 are provided as categories on NSData. You will need to link with libz and libcrypto if you use these.

If you have any questions, comments, or code, you can send them to Michael Ash at mail@mikeash.com, or on AIM screen name (or whatever it's called) mikeash47.
